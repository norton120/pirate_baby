---
title: "An Indian Summer for Old Programmers"
date: 2024-2-20
draft: true
---
### History
The most money I have ever made was selling motorcycles. Software Engineering is by all means a lucrative profession, and I never have been a starving artist developer who prizes a compelling mission over a compelling paycheck. But the years I sold motorcycles - between 2003 and 2008 - coincided with a wave of temporary insanity in the US real estate market. Otherwise normal people became mad with the sudden access to "wealth," in the form of massive home equity reserves they could spend as easily as cash via HELOC checkbooks. And spend they did - in my dealership, to the tune of $100,000 boats, $50,000 Harley Davidsons, and $30,000 jetskis, often two or three at a time ("get the pair or the garage will look lopsided"). This was a time when ex-convict, high-school dropout motorcycle salesman would net twice the income of the Ivy-league lawyer to whom they were selling that overpriced jetboat. As salespeople we assumed this prosperity to be an eternal constant, and we planned, spent, and generally behaved accordingly. The Saturday after Lehman Brothers toppled in the fall of 2008, I walked out to make sure the front doors of the dealership were unlocked. Twice. Every Saturday before that one, I would look out from my elevated office and see thousands of customers across the two-hundred-yard-long dealership floor. But that Saturday, the customers numbered in single digits, and the sight of listless, terrified salespeople dominated the floor. In the coming months, most of the sales force saw their incomes vanish and their savings evaporate; suddenly earning little more than minimum wage and saddled with debts acquired as six-figure earners, these were hard times. Amidst this barren economic winter, there was a sudden reprieve in the form of the Southern California gas price explosion. Economic forces combined to send the price of a gallon to just under $5 (that's over $7 a gallon today), and Angelinos again panicked - this time stampeding to our dealership to purchase 70-plus-mpg scooters and motorcycles. At one point we partnered with a local car dealer so customers could trade in their massive SUVs and lifted trucks (for a sizable loss) and pay top dollar for a Vespa clone. By all accounts the gravy days were back, and most of the salespeople resumed decadence as usual. But the seasoned ones, the wise old oaks (probably in their 30's now that I think of it) maintained caution. They used this temporary reprieve to right-size, and reposition themselves. One sold his mansion (there is no other word for that house) to an eager young co-worker for a sizable, but still tolerable, loss. Another sold off all his cars for cost, to ready buyers still viewing the world with 2006 price tags. Of course the scooter bubble quickly burst, and what was left was nearly half a decade of the worst sales and slowest rebound in the history of power sports. 

### History Repeats Itself
I feel I'll tell a very similar story of Software/Data/DevOps (et al) Engineering in the not-to-distant future. A slow-burning period of unsustainable gluttony followed immediately by a devastating correction. Then a moment of opportunity, mistaken by most to be a return of "the good times", and finally, a long plunge into sensible reality. This is a common narrative right now, and I'll only touch on the first two parts (the past decadence and the inevitable correction) enough to set the stage. What I think matters today, and the heart of this writing, is a dissection of that critical window of opportunity. 

#### It was the best of times
We all know the stories. (M/F)AANG employees outraged that their favorite cereal is no longer stocked at the closest snack station during company all-hands, and CompSci grads dumbfounded that their first job would expect a five-day work week. Then the more mundane (but no less tell-tale) evidence; recruiters hounding anyone titled "developer" day and night with six-figure job offers, lavish perks that sometimes sounded less like work and more like a cruise ship ("we have a climbing wall!"). Rock-star impunity derived from an unspoken understanding of who was "the talent," in great demand and terribly difficult to replace. And of course, a shared cognative dissidence in ignoring developer ROI (and lack there of).  To call the last decade of Software Engineers the bourgeoisie would be innacurate only in that Aristocracy was often more befitting. 

#### It was the worst of times
We know these stories too. (M/F)AANG tech layoffs in the range of 40,000 people (as of 2/24), with more likely to come. 320,000+ layed off across tech in 23/24. VC funding at the lowest point in 6 years, and 62% lower than the funding peak of 2022. Engineers that had only recently settled into cushy management jobs suddenly upended, taking consulting or contract work to fill the gap. Post after painful social media post from displaced big tech Engineers who can't seem to find that next role. And a looming fear of Artificial Intelligence that might quickly automate away once thought "sacred" and un-automatable skills.

#### The Indian summer
During these "dark times", OpenAI went from $29B to over $80B in value. 20 new AI unicorns were minted in 2023 (the slowest year for new unicorns in half a decade). Good fortune abounds for an Engineer wishing to join the AI cash grab; typically it is as easy as wrapping the OpenAI api in a few lines of javascript and running to the nearest investor with an open wallet. "Look my app summerizes {thing}!" "My app has a personality like Joe Pesci!" and the checks pile up.

But remember I called this moment a moment of opportunity. Not an opportunity for a short-lived buck, but to carve out a soft landing and safe passage into the sensible world to come. This is not an opportunity for everyone; in fact, the disadvantages that make it untennable by so many people in the Engineering field is part of what makes it an opportunity. But opportunities tend to be like that - and if this one does not favor you, then the next very well might. 
For our purposes let's focus on statistical models, language models, and machine learning implementations. If you look past the generative AI hype and ask what the larger set of AI tools offer, the answer is pretty simple - these tools give you a way to make computers do things that are really hard (or functionally impossible) to do without them. For a seasoned programmer this is not a new paradigm; every time you have adopted a new tool or learned a new language, it was because doing so expanded your plane of influence. Consider: at some early point in your career, you probably wanted to keep state between runs of your program but didn't know how. So you learned how to interact with a database.  Instantly, something that was impossible before (saving state) was now quite reasonable. It wasn't free knowledge or magic - adding state to a program (along with the complexity of database adapters and idiosyncrasies) introduces new challenges, new elements for you to master in your design. But this _ability_ of your program was unblocked. 
Today, you might want the results from your program to improve based on feedback from users. So you learn how to create an ML training loop, applying user-provided scores to a dataset which is fed back into the training cycle. Instantly, something that was impossible before (progressive self-improvement of your program's output) is now quite reasonable.  
The database example has useful parallels; in the late 1980's database innovation  came from commercial closed-source powerhouses like Microsoft SQL Server and Oracle, and OSS projects like Postgresql (and later MySQL). With the focus on OOP during the dot-com era, the first ORM and MVC patterns (both in Smalltalk) arrived in 1995. Even so, by 2004 many of us were building PHP PDO models that amounted to 10,000 line bricks of stringified SQL queries. If you use any ORM today you expect to be able to do things like `user.save()` or `user.reset_password()` to update a user, not `database.run_query("UPDATE user SET(u.first_name, u.last_name # etc for 30 more lines`. The proliferation of MVC + ORM frameworks like Spring, Ruby on Rails and Django did not introduce any revolutionary database technology, nor did they represent a leap forward in computer science. They leveraged a very different technology, _application design principals_, and fostered a leap forward in the _developer experience_. I see the same challenges in the generative AI landscape today as post-dot-com web development: flush with technology, pale in structure.  
[Instructor](https://github.com/jxnl/instructor) is a library I used in a project about a year ago which monkey patches the OpenAI sdk to enforce response classes. Instructor released an ORM integration last week, allowing database objects and LLM objects to be swapped directly. The project is tightly coupled to the OpenAI product and I don't see the ORM integration evolving past a novelty - a service generating db objects in a vaccuum is kind of pointless, and I think you'll end up wrapping the classes and basically building them into oddly shaped tools calls to get any real value from it. But the idea does spark thoughts around what LLM software could look like, what form the abstractions could take on within a mature framework. This is the question we should all be asking right now, and one the old programmers are uniquely able to answer. 

#### What's out there
The crop of OSS generative AI projects fall largely into one of two categories: mostly academic or mostly inexperienced. 

The **mostly academic** projects are driven by (no surprise here) data-focused researchers in academia. Projects like [MemGPT](https://memgpt.ai/) are filled with technically brilliant concepts and truly revolutionary solutions to computing problems. What they lack is design patterns, implementation strategy, or any sense of a cohesive developer API. These are typically pseudocode-that-runs, a whiteboard thought exercise in how a solution _might_ work squeezed into production. MemGPT is not a framework or a library, it is an exciting proof-of-concept. 

The **mostly inexperienced** projects are motivated, fast-moving, and entirely focused on the wrong shiny objects. These are very high-profile, generally VC backed endeavors. They tout their number of "tool integrations" - i.e. how many API wrappers they have plugged into the code base - as the benchmark by which they compete. This might make sense many cycles in the future once the core project capabilities are sound bedrock, similar to the 5,000 + integrations in the `django-pakages` registry. But with the current trajectory, I don't foresee most of these projects ever reaching that maturity; they seem most impressed with what "coding can do," focused on the novelty of giving an LLM access to Jira, less interested in ensuring that access produces robust, polished, reliable, and ultimately useful outcomes. The rush to create novel prompt templating solutions is a fantastic example of this; if there is one thing that is a solved problem in nearly every programming language, it is "how can I generate dynamic text within templated outputs?" The answer is, the same way we generate HTML in every server-side rendered or SPA framework, and the same way we compile SQL in dbt. Understanding the difference between an unsolved problem and a problem you _personally_ have not yet solved is a critical part of experience, something that is painfully lacking in the OSS AI ecosystem today. 

Between the two, I believe the opportunity moment for old programmers lies within transforming the mostly academic projects first. These projects need veteran programmers to think through what a framework for this technology should look like, and implement it. Framework builders, meta programmers that can consider the entire lifespan of the software and the whole of the developer experience. The change agent here will be a David Heinemeier Hansson, not an Alan Turing. But evolution does not happen in a bubble, and there will come a time (sooner than most think I believe) when the luster of the mostly inexperienced projects will decay from poorly built foundations; here too, the old programmers, who are no strangers to righting the path of a lost ship, will find their place.  

#### A perfect storm of opportunity
But why old programmers? What makes this demand for framework-building, design-pattern-minded Software Engineers the exclusive domain of the graybeards? AI is supposedly a young person's game, and only a few years ago we were informed that an impending army of bootcamp grads and CompSci majors were coming to commodize the field. How can I possibly argue that the face of change in AI looks more like the cast of RED than High School Musical?

First, meta-programming and framework building are hard. Really hard. They are the difference between knowing to use  `user.update(name='dave')` to save a name, and writing the underlying code that powers the `update()` function. For many CS and now bootcamp grads, programming is just a good paying job - one that they can get by fine in without any knowledge of the latter. Those same people also existed twenty years ago, but it is unlikely they are "old programmers" today. Instead, they are Sysadmins and District Managers and CSOs, people that "used to code." And there's very little risk of any of them (old or new) striking out to build the next enterprise AI framework.

Secondly, I believe that there would be a glut of hyper-talented, reasonably experienced, lightly seasoned younger Software Engineers on the market today, had it not been for (F/M)AANG and their big tech ilk swooping in like the spacecraft from WAL-E to pacify and infantalize huge swaths of dev talent. Are there remarkably bright, highly skilled 26-year-olds that escaped from Google with more knowledge and experience than I ever will posses? Absolutely. But there are far fewer of them than should be, given the spike in popularity of CS degrees and the proliferation of boot camps, online programs, and free resources now available. Old programmers owe this good fortune to the opulent insanity of the last decade; every excess Engineer Facebook hired only to keep them off the market, rotting without work, is one less seasoned programmer on the market today. Junior devs that came of age in the 20/80 work/life "balance" of far too many tech teams are still junior devs today, because that lack of seat time translated into a lack of skills progression. 

If you are an old programmer - the kind of salt that still remembers what all the letters in SOLID stand for, that once had _Patterns of Enterprise Application Architecture_ on your nightstand, that actually understands DNS - then this is your call to service. Put down the _world's greatest Regional VP_ mug, dust off the keyboard, and get into the fray of Artificial Intelligence Software Design where your skills are most needed. Help usher in the next generation of quality software, and secure your place in a rapidly approaching future. The opulent past of recent years needed software managers-of-managers, the AI-driven enterprises of tomorrow 

#### the old motorcycle salesman
- rickman and his little book of birthdays
- what that looks like for us, if we take the opportunity
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE5Mzk2MzM5Niw2MDExMDk4OTgsLTUyMD
M5MDQ0NiwxMTgxMTQwMzA4LC0yNzU0MjU1NTAsMjQ1ODkwODk3
LC0xMjEzNjk4Mzc0LC0xMzMxMTk5Nzk4LC0xMDEzOTQwMTMxLD
k3MjczNTE4MCwtMTcyMjc5NzMyNSwtMTA4NDM0NTY0MywtMTky
Njg2Mjg1MywxMjUxMDUyMDMzLDEwMTYxMTk0NTMsLTE5MzAzNj
EzMSwxOTUyNTc1MDExLC00NjQyMDc2MzMsLTM0ODU0MzkxNiwy
MjA2MDI4NF19
-->