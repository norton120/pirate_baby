<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>50 First Dates With MemGPT | the Pirate Baby</title>
<meta name="keywords" content="ai, ml">
<meta name="description" content="preamble The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. &ldquo;You can&rsquo;t just let it be romantic. Why do you have to ruin everything!?!&rdquo; We had just seen 50 First Dates, a classic Sandler/Barrymore romance about a woman who&rsquo;s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own &ldquo;external memory&rdquo; via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide.">
<meta name="author" content="">
<link rel="canonical" href="http://0.0.0.0:1313/posts/50_first_dates_with_memgpt/">

  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QYLKP2XXPB"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-QYLKP2XXPB');
        }
      </script>
    
  


<link crossorigin="anonymous" href="/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css" integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://0.0.0.0:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://0.0.0.0:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://0.0.0.0:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://0.0.0.0:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://0.0.0.0:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://0.0.0.0:1313/posts/50_first_dates_with_memgpt/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QYLKP2XXPB"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-QYLKP2XXPB');
        }
      </script>
    
  

<meta property="og:title" content="50 First Dates With MemGPT" />
<meta property="og:description" content="preamble The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. &ldquo;You can&rsquo;t just let it be romantic. Why do you have to ruin everything!?!&rdquo; We had just seen 50 First Dates, a classic Sandler/Barrymore romance about a woman who&rsquo;s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own &ldquo;external memory&rdquo; via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://0.0.0.0:1313/posts/50_first_dates_with_memgpt/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-02-25T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="50 First Dates With MemGPT"/>
<meta name="twitter:description" content="preamble The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. &ldquo;You can&rsquo;t just let it be romantic. Why do you have to ruin everything!?!&rdquo; We had just seen 50 First Dates, a classic Sandler/Barrymore romance about a woman who&rsquo;s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own &ldquo;external memory&rdquo; via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://0.0.0.0:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "50 First Dates With MemGPT",
      "item": "http://0.0.0.0:1313/posts/50_first_dates_with_memgpt/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "50 First Dates With MemGPT",
  "name": "50 First Dates With MemGPT",
  "description": "preamble The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. \u0026ldquo;You can\u0026rsquo;t just let it be romantic. Why do you have to ruin everything!?!\u0026rdquo; We had just seen 50 First Dates, a classic Sandler/Barrymore romance about a woman who\u0026rsquo;s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own \u0026ldquo;external memory\u0026rdquo; via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide.",
  "keywords": [
    "ai", "ml"
  ],
  "articleBody": "preamble The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. “You can’t just let it be romantic. Why do you have to ruin everything!?!” We had just seen 50 First Dates, a classic Sandler/Barrymore romance about a woman who’s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own “external memory” via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide. I had done shorthand math while the credits were rolling: If Lucy’s average diary entry took 20 minutes to write (that is less than most people, and most people aren’t trying to compensate for brain damage), each entry would take roughly half that time - so about 10 minutes - to read. Reading a week’s entries would take more than an hour. By the 6 month mark, the daily catch-up on her past would require more hours of reading than are in a day. Romantic? Yes. Realistic? No. And so we argued. I believe the conversation went something like this:\n\"Her: But what if every Sunday she made wrote a cheat sheet for the past week, and then she only read those? That would take less time. “ ”Me: Even a weekly summary would become unreadable in less than a year.\" \"Her: OK, then what if she summarized those cheat sheets?? She could keep making the history smaller and smaller.\" \"Me: Yeah but eventually she’d lose too much detail and the summaries would be useless.\" \"Her: But she’d still have her daily journals for when she needs those details!\" \"Me: How would she ever search that? We’re back where we started.\"\nTwenty years later, the “Lucy problem” is a perfect lens to help us understand one of the most important challenges in designing a Large Language Model Agent Framework. The solution proposed by researchers at UC Berkeley is remarkably innovative and offers exciting potential - and it is a solution that bears significant resemblance to the “Lucy solution” I was arguing against during that car ride home. It looks like I owe someone a long overdue apology.\nLucy the language model: a near-perfect analogy Large Language Models are, in reality, just functions. You input at least one argument (text) and they output in kind. This output is the product of the model’s business logic, combined parameters, and internal arguments - one of those arguments being the training data used to develop the inference model. This training data serves as the model’s “memories”; without it the LLM would output very little of value, similar to attempting a deep conversation with a newborn. The training data “memories” in an large language model are fixed at inference time, exactly like Lucy’s memories in the movie. She has developed experiences and gathered information up to a very specific point (in her case, the day of her accident); from that day forward, she interprets stimuli based on the exact state of her mind, her memories, at that time. This is precisely how inference with a large language model operates - fixed to the moment the training was complete, and the resulting function was pickled.\nEach time the LLM function is executed (here we will refer to this combined execution and response as a turn, borrowing from chat nomenclature) is exactly like one single day in the life of Lucy. With the model temperature turned down to 0 (deterministic) each turn with the same input will look exactly like Lucy’s early routine - repeating the same day over and over (and baking a lot of identical birthday cakes). An LLM cannot form new “memories” as a pure inference endpoint, any more than Lucy can.\nTo compensate for this with an LLM, the natural next step is to prepend those new “memories” as part of the text passed to the LLM function effectively augmenting the training data of the language model for the duration of the turn1. However language model context windows - the combined amount of text that can be input and output in a single turn - are limited in size. Again, this is exactly how Barrymore’s character experiences the world; her context window is one single day. Just as I argued so many years earlier that Lucy’s memories would eventually take longer to consume than there are hours in a day for her to retain them, new knowledge that must be included in a turn in order for the language model to produce a useful output quickly outgrows the available context window.\nThe limits of prompt engineering The lion’s share of LLM Engineering coverage has been devoted to prompt engineering, or crafting the content we submit in a turn so that it produces the most desirable outcome. An entire ecosystem has rapidly developed around prompt design, from prompt engineering classes to prompt exchange marketplaces - all from the idea that from the “perfect prompt” you can coax the “perfect output.”\nHenry, Sandler’s character in 50 First Dates, may have been one of the earliest prompt engineers. Early in the film Henry falls in love with Lucy and agrees not to tell her about her injury, instead wooing her anew each day. His daily “prompts” to re-win her heart begin abysmally, with most ending in rejection. Over time his technique evolves until Lucy consistently falls for him every day. We see this same example in countless language model demos, where a meticulously crafted prompt is used to visualize analytics for a dataset, or generate a spot-on cover letter.\nThe examples are impressive, but how useful is this prompting really? In the movie, Henry finally addresses the extreme limitations in a life of infinite first dates, and tells Lucy about her condition. With a language model, a “perfect prompt” executed in isolation is just as limited in value. Complex tasks require many complex steps, each building on a modified state - and this cannot be accomplished in a single turn. While prompt engineering is certainly an important piece of the puzzle, it isn’t remotely a holistic solution to our problem.\nRAG, a newspaper, and a video tape For both Lucy and the language model, things get interesting once we start externalizing memories. Retrieval Augmented Generation (RAG) is probably a close second to prompt engineering in the sheer volume of attention paid in LLM-related content. RAG can be more simply stated as “store text somewhere, then on each turn search that text and add bits to the prompt.” The most common RAG implementations today are blind semantic searches, where every user input is searched against the RAG store by semantic similarity, and then the top few search results are combined with the user input as the prompt. They look something like this:\n# prompt with just user input Question: What is the last thing Todd said before he quit yesterday? vs\n# prompt with vector similarity search results for \"What is the last thing Todd said before he quit yesterday?\" via embeddings, prepended to prompt Context: \"Margo: Todd is quitting today!\" \"Todd: I am quitting today. I've had enough.\" \"Clark: I can't believe Todd finally quit, Margo is going to freak.\" Question: What is the last thing Todd said before he quit yesterday? The context injected by RAG might be very helpful, or it might be virtually irrelevant. What’s more, the question may not require the context at all, and the RAG may just be noise.\nAgain 50 First Dates does not disappoint with real-world analogs. In the film, Lucy’s condition is kept hidden from her with the help of falsified context clues; her father swaps out her newspaper with a reprinted one, passes off a recorded football game as live TV, and paints over a wall every evening so she can re-paint it the next day, none the wiser. This context adds to the prompt and allows Lucy to live a full day (albeit the same one over and over). It does a significantly better job of reaching the desired outcome (Lucy enjoys her day and is able to function within it) than relying completely on the day’s organic events. Later, Henry introduces the first attempt to be honest with Lucy in the form of a VHS recording. To the plot of the film this is a pivotal moment, as it is Lucy’s first step towards regaining agency. With the language model, it is functionally the same as the newspaper and the paint; each turn is potentially better and more informed when it includes RAG content, but it is still very much an isolated turn without true external state management.\nRegardless of which Lucy consumes - the fake newspaper or Henry’s real VHS tape - improvement in Lucy’s life is limited to the outcome of that day. Lucy still has no agency to live a full life, just as our language model can take no meaningful steps towards completing a complex task.\nJust like prompt engineering, RAG is a piece of the puzzle, but it is not the answer in and of itself.\nA mind with a diary Let’s review that theory from the car. What if Lucy kept a diary, and then managed this “external memory” by summarizing, consolidating, and making herself cheat sheets? Unlike her father’s newspapers or Henry’s VHS tapes, this memory would be completely under her control. She decides what information is critically important, what memories can be forgotten, and what knowledge should live on in “cold storage” to be dredged up only when required. The film touches on this idea (though it took my romance-ruining logic to really see it played out in detail). With an external memory like this, Lucy is now unbound from her context window. She can pursue her interests for as long as they take, participate actively in the mundane but important events of life, have a family, live. She can make a menu for the week on Monday, go shopping for groceries Wednesday, and cook them on Friday - all the elements of agency returned to her by a few notebooks and todo lists.\nThis is remarkably similar to the premise behind the MemGPT project2. The context window, chat history, and RAG knowledge store are treated as tiered “memories”; each memory can be written and purged by the LLM using tool calls. Instead of approaching each turn as an isolated prompt + RAG + input = response, the “core” memory (the context window content) is processed continually as a daemon, with a new turn on each “heartbeart.” Just as each day Lucy is presented with her notes and todo list from the previous day, with each turn the language model is presented with the core memory assembled by the previous turn. During that turn the language model can edit this core memory, move information out of core and into archival memory, or search/recall from archival memory and add that back to core, and these changes will apply to the core memory presented in the next turn.\nHere’s a walk-through of how an agent could work (with a bit of pseudo-code) to answer a user’s question about a company. The agent has a core memory describing itself and the user, a history section containing the last five messages, and a list of tools the agent can call. This core memory is passed as the prompt in a turn every 10 seconds, or sooner if externally triggered.\nOn the first pass the agent calls the archive_lines() tool to move the 2nd paragraph of the user information to cold storage. Why? because the system prompt informs the agent of the current and max memory sizes, and instructs the agent to self-adjust when needed. On the next pass, the tool call request and result are the newest entries in the core memory history (the 2 oldest from the last turn have been moved to recall memory and are not visible). This turn the agent calls pause_heartbeats() to wait for external stimuli, as it detects nothing else to update in it’s own core memory. The next turn is triggered by a user message, which is the newest history entry in this turn’s core memory. The user message says “how many people are in the Seattle office?” and the agent’s first action is to call the get_employee_list() tool, along with the internal monologue message “I must get the list of employees and count only the ones in the Seattle office. I must then send the message back to the user” . On the next turn, the agent tool call, internal monologue, and tool call result are in the core memory history, but the original user message has been pushed out. On this turn the agent’s internal monologue is “65 employees are in the Seattle office. I must retrieve the original question so I can answer it correctly” and the tool call is retrieve_message(user, -1) to get the last message from the user. On the next turn, the agent calls send_message(\"there are 65 employees in the Seattle office\"), and responds to the user. And the beat goes on.\nThis “language model operating system” is a starkly contrasting view of how inference services could function to complete complex, multifaceted tasks. It also changes the paradigm of “evolution” as an agent, allowing the application to adjust and self-correct. Prompts and RAG become correctable elements within a generative “cycle”; if a RAG search is ineffective or prompt misses the mark, it can be re-tried or compensated for on the next turn. Most distinctly important from single-turn agent design, the results of this self-managed memory are cumulative. This is an absolute necessity for true agency.\nI am very excited about what a framework built on this concept could mean; adding stimuli to a well-appointed agent (or cluster of agents) becomes an execution layer that evolves beyond text generation and an ROI that grows exponentially with the complexity of its’ charge. A language model operating in this fashion is still a language model - a function, not a sentient being - but it crosses a threshold of appearance that is the stuff of Sci-Fi. More importantly, it adds a critical element to the generative equation that I just don’t see autonomous agency succeeding without: repetition. Humans don’t immediately think every required thought and blurt out the perfect response in one breath; we take steps, ask questions that uncover new questions, pause to consider internally, and arrive at an answer. By bestowing that same capacity on an application, this language model operating system could be a new paradigm in computing.\nFor those of us building user-facing agents, this is a concept worth focus and cycles. Single-turn prompt libraries and slice-and-dice embedding building to RAG away bad responses was the best idea we had in the dark AI days of 6 months ago, but I don’t think they will get us where we want to go. In 50 First Dates Lucy married Henry, became a mom, and sailed to Alaska, all because she was restored the agency to own her mind and manage her memories. Language model agents need the same in an “operating system” if we want to unlock them.\nJoin me next time, when we explore the parallels between Happy Gilmore and K8S (hint: there are none).\nFootnotes: 1. Adding context to a prompt and fine-tuning or retraining a model are not really the same thing, but I was willing to take a few liberties with technical accuracy for the sake of clearly demonstrating the subject concepts.\n2. Note that throughout this writing I am referring to the concepts introduced by the research behind MemGPT, not the implementation itself. The nomenclature, pseudo-code, and description of events here are not intended to reflect the software project.\nMemGPT Citation: packer 2023 memgpt, MemGPT: Towards LLMs as Operating Systems, authors: Packer, Charles and Wooders, Sarah and Lin, Kevin and Fang, Vivian and Patil, Shishir G. and Stoica, Ion and Gonzalez, Joseph E., arXiv preprint arXiv:2310.08560\n",
  "wordCount" : "2672",
  "inLanguage": "en",
  "datePublished": "2024-02-25T00:00:00Z",
  "dateModified": "2024-02-25T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://0.0.0.0:1313/posts/50_first_dates_with_memgpt/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "the Pirate Baby",
    "logo": {
      "@type": "ImageObject",
      "url": "http://0.0.0.0:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://0.0.0.0:1313/" accesskey="h" title="the Pirate Baby (Alt + H)">
                        
                    <img src="http://0.0.0.0:1313/piratebaby_huaab79433917d743d4e178df45e5313e8_505492_0x40_resize_box_3.png" alt="" aria-label="logo"
                        height="40">the Pirate Baby</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://0.0.0.0:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://0.0.0.0:1313/work-with-pirate-baby/" title="C&amp;C">
                    <span>C&amp;C</span>
                </a>
            </li>
            <li>
                <a href="http://0.0.0.0:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://0.0.0.0:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://0.0.0.0:1313/">Home</a>&nbsp;»&nbsp;<a href="http://0.0.0.0:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      50 First Dates With MemGPT
    </h1>
    <div class="post-meta"><span title='2024-02-25 00:00:00 +0000 UTC'>February 25, 2024</span>&nbsp;·&nbsp;13 min

</div>
  </header> 
  <div class="post-content"><h2 id="preamble">preamble<a hidden class="anchor" aria-hidden="true" href="#preamble">#</a></h2>
<p>The drive home from the movie theater was not going well. My then-girlfriend sat arms crossed in the passenger seat, the red glow from the traffic light matching her mood. &ldquo;You can&rsquo;t just let it be romantic. Why do you have to ruin everything!?!&rdquo; We had just seen <em>50 First Dates</em>, a classic Sandler/Barrymore romance about a woman who&rsquo;s brain injury prevents her from forming long-term memories. In the movie, Lucy (Barrymore) constructs her own &ldquo;external memory&rdquo; via her diary; a clever plot device, but one that required suspension of disbelief that I just could not abide. I had done shorthand math while the credits were rolling: If Lucy&rsquo;s average diary entry took 20 minutes to write (that is less than most people, and most people aren&rsquo;t trying to compensate for brain damage), each entry would take roughly half that time - so about 10 minutes - to read. Reading a week&rsquo;s entries would take more than an hour. By the 6 month mark, the daily catch-up on her past would require more hours of reading than are in a day. Romantic? Yes. Realistic? No. And so we argued.
I believe the conversation went something like this:</p>
<p><em>&quot;<strong>Her</strong>: But what if every Sunday she made wrote a cheat sheet for the past week, and then she only read those? That would take less time. &ldquo;</em>
<em>&rdquo;<strong>Me</strong>: Even a weekly summary would become unreadable in less than a year.&quot;</em>
<em>&quot;<strong>Her</strong>: OK, then what if she summarized those cheat sheets?? She could keep making the history smaller and smaller.&quot;</em>
<em>&quot;<strong>Me</strong>:  Yeah but eventually she&rsquo;d lose too much detail and the summaries would be useless.&quot;</em>
<em>&quot;<strong>Her</strong>: But she&rsquo;d still have her daily journals for when she needs those details!&quot;</em>
<em>&quot;<strong>Me</strong>: How would she ever search that? We&rsquo;re back where we started.&quot;</em></p>
<p>Twenty years later, the &ldquo;Lucy problem&rdquo; is a perfect lens to help us understand one of the most important challenges in designing a Large Language Model Agent Framework. The solution proposed by <a href="https://research.memgpt.ai/">researchers at UC Berkeley</a> is remarkably innovative and offers exciting potential - and it is a solution that bears significant resemblance to the &ldquo;Lucy solution&rdquo; I was arguing against during that car ride home. It looks like I owe someone a long overdue apology.</p>
<h2 id="lucy-the-language-model-a-near-perfect-analogy">Lucy the language model: a near-perfect analogy<a hidden class="anchor" aria-hidden="true" href="#lucy-the-language-model-a-near-perfect-analogy">#</a></h2>
<p>Large Language Models are, in reality, just functions. You input at least one argument (text) and they output in kind. This output is the product of the model&rsquo;s business logic, combined parameters, and internal arguments - one of those arguments being the training data used to develop the inference model. This training data serves as the model&rsquo;s &ldquo;memories&rdquo;; without it the LLM would output very little of value, similar to attempting a deep conversation with a newborn.
The training data &ldquo;memories&rdquo; in an large language model are fixed at inference time, exactly like Lucy&rsquo;s memories in the movie. She has developed experiences and gathered information up to a very specific point (in her case, the day of her accident); from that day forward, she interprets stimuli based on the exact state of her mind, her memories, at that time. This is <em>precisely</em> how inference with a large language model operates - fixed to the moment the training was complete, and the resulting function was pickled.</p>
<p>Each time the LLM function is executed (here we will refer to this combined execution and response as a <em>turn</em>, borrowing from chat nomenclature) is exactly like one single day in the life of Lucy. With the model temperature turned down to 0 (deterministic) each turn with the same input will look exactly like Lucy&rsquo;s early routine - repeating the same day over and over (and baking a lot of identical birthday cakes). An LLM cannot form new &ldquo;memories&rdquo; as a pure inference endpoint, any more than Lucy can.</p>
<p>To compensate for this with an LLM, the natural next step is to prepend those new &ldquo;memories&rdquo; as part of the text passed to the LLM function effectively augmenting the training data of the language model for the duration of the turn<sup>1</sup>. However language model context windows - the combined amount of text that can be input and output in a single turn - are limited in size. Again, this is <em>exactly</em> how Barrymore&rsquo;s character experiences the world; her context window is one single day. Just as I argued so many years earlier that Lucy&rsquo;s memories would eventually take longer to consume than there are hours in a day for her to retain them, new knowledge that must be included in a turn in order for the language model to produce a useful output quickly outgrows the available context window.</p>
<h2 id="the-limits-of-prompt-engineering">The limits of prompt engineering<a hidden class="anchor" aria-hidden="true" href="#the-limits-of-prompt-engineering">#</a></h2>
<p>The lion&rsquo;s share of LLM Engineering coverage has been devoted to <em>prompt engineering</em>, or crafting the content we submit in a turn so that it produces the most desirable outcome. An entire ecosystem has rapidly developed around prompt design, from prompt engineering classes to prompt exchange marketplaces - all from the idea that from the &ldquo;perfect prompt&rdquo; you can coax the &ldquo;perfect output.&rdquo;</p>
<p>Henry, Sandler&rsquo;s character in <em>50 First Dates</em>, may have been one of the earliest prompt engineers. Early in the film Henry falls in love with Lucy and agrees not to tell her about her injury, instead wooing her anew each day. His daily &ldquo;prompts&rdquo; to re-win her heart begin abysmally, with most ending in rejection. Over time his technique evolves until Lucy consistently falls for him every day. We see this same example in countless language model demos, where a meticulously crafted prompt is used to visualize analytics for a dataset, or generate a spot-on cover letter.</p>
<p>The examples are impressive, but how useful is this prompting really? In the movie, Henry finally addresses the extreme limitations in a life of infinite first dates, and tells Lucy about her condition. With a language model, a &ldquo;perfect prompt&rdquo; executed in isolation is just as limited in value. Complex tasks require many complex steps, each building on a modified state - and this cannot be accomplished in a single turn. While prompt engineering is certainly an important piece of the puzzle, it isn&rsquo;t remotely a holistic solution to our problem.</p>
<h2 id="rag-a-newspaper-and-a-video-tape">RAG, a newspaper, and a video tape<a hidden class="anchor" aria-hidden="true" href="#rag-a-newspaper-and-a-video-tape">#</a></h2>
<p>For both Lucy and the language model, things get interesting once we start externalizing memories. Retrieval Augmented Generation (RAG) is probably a close second to prompt engineering in the sheer volume of attention paid in LLM-related content. RAG can be more simply stated as &ldquo;store text somewhere, then on each turn search that text and add bits to the prompt.&rdquo; The most common RAG implementations today are blind semantic searches, where every user input is searched against the RAG store by semantic similarity, and then the top few search results are combined with the user input as the prompt. They look something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl"># prompt with just user input
</span></span><span class="line"><span class="cl">Question: What is the last thing Todd said before he quit yesterday?
</span></span></code></pre></div><p>vs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl"># prompt with vector similarity search results for &#34;What is the last thing Todd said before he quit yesterday?&#34; via embeddings, prepended to prompt
</span></span><span class="line"><span class="cl">Context:
</span></span><span class="line"><span class="cl">&#34;Margo: Todd is quitting today!&#34;
</span></span><span class="line"><span class="cl">&#34;Todd: I am quitting today. I&#39;ve had enough.&#34;
</span></span><span class="line"><span class="cl">&#34;Clark: I can&#39;t believe Todd finally quit, Margo is going to freak.&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Question: What is the last thing Todd said before he quit yesterday?
</span></span></code></pre></div><p>The context injected by RAG might be very helpful, or it might be virtually irrelevant. What&rsquo;s more, the question may not require the context at all, and the RAG may just be noise.</p>
<p>Again <em>50 First Dates</em> does not disappoint with real-world analogs. In the film, Lucy&rsquo;s condition is kept hidden from her with the help of falsified context clues; her father swaps out her newspaper with a reprinted one, passes off a recorded football game as live TV, and paints over a wall every evening so she can re-paint it the next day, none the wiser. This context adds to the prompt and allows Lucy to live a full day (albeit the same one over and over). It does a significantly better job of reaching the desired outcome (Lucy enjoys her day and is able to function within it) than relying completely on the day&rsquo;s organic events.
Later, Henry introduces the first attempt to be honest with Lucy in the form of a VHS recording. To the plot of the film this is a pivotal moment, as it is Lucy&rsquo;s first step towards regaining agency. With the language model, it is functionally the same as the newspaper and the paint; each turn is potentially better and more informed when it includes RAG content, but it is still very much an isolated turn without true external state management.</p>
<p>Regardless of which Lucy consumes - the fake newspaper or Henry&rsquo;s real VHS tape - improvement in Lucy&rsquo;s life is limited to the outcome of that day. Lucy still has no agency to live a full life, just as our language model can take no meaningful steps towards completing a complex task.</p>
<p>Just like prompt engineering, RAG is a piece of the puzzle, but it is not the answer in and of itself.</p>
<h2 id="a-mind-with-a-diary">A mind with a diary<a hidden class="anchor" aria-hidden="true" href="#a-mind-with-a-diary">#</a></h2>
<p>Let&rsquo;s review that theory from the car. What if Lucy kept a diary, and then managed this &ldquo;external memory&rdquo; by summarizing, consolidating, and making herself cheat sheets? Unlike her father&rsquo;s newspapers or Henry&rsquo;s VHS tapes, this memory would be completely under her control. <em>She</em> decides what information is critically important, what memories can be forgotten, and what knowledge should live on in &ldquo;cold storage&rdquo; to be dredged up only when required. The film touches on this idea (though it took my romance-ruining logic to really see it played out in detail). With an external memory like this, Lucy is now unbound from her context window. She can pursue her interests for as long as they take, participate actively in the mundane but important events of life, have a family, <em>live</em>. She can make a menu for the week on Monday, go shopping for groceries Wednesday, and cook them on Friday - all the elements of agency returned to her by a few notebooks and todo lists.</p>
<p>This is remarkably similar to the premise behind the <a href="https://memgpt.ai/">MemGPT</a> project<sup>2</sup>. The context window, chat history, and RAG knowledge store are treated as tiered &ldquo;memories&rdquo;; each memory can be written and purged by the LLM using tool calls.
Instead of approaching each turn as an isolated prompt + RAG + input = response, the &ldquo;core&rdquo; memory (the context window content) is processed continually as a daemon, with a new turn on each &ldquo;heartbeart.&rdquo; Just as each day Lucy is presented with her notes and todo list from the previous day, with each turn the language model is presented with the core memory assembled by the previous turn. During that turn the language model can edit this core memory, move information out of core and into archival memory, or search/recall from archival memory and add that back to core, and these changes will apply to the core memory presented in the next turn.</p>
<p>Here&rsquo;s a walk-through of how an agent could work (with a bit of pseudo-code) to answer a user&rsquo;s question about a company. The agent has a core memory describing itself and the user, a history section containing the last five messages, and a list of tools the agent can call. This core memory is passed as the prompt in a turn every 10 seconds, or sooner if externally triggered.</p>
<ol>
<li>On the first pass the agent calls the <code>archive_lines()</code> tool to move the 2nd paragraph of the user information to cold storage. Why? because the system prompt informs the agent of the current and max memory sizes, and instructs the agent to self-adjust when needed.</li>
<li>On the next pass, the tool call request and result are the newest entries in the core memory history (the 2 oldest from the last turn have been moved to recall memory and are not visible). This turn the agent calls <code>pause_heartbeats()</code> to wait for external stimuli, as it detects nothing else to update in it&rsquo;s own core memory.</li>
<li>The next turn is triggered by a user message, which is the newest history entry in this turn&rsquo;s core memory. The user message says &ldquo;how many people are in the Seattle office?&rdquo; and the agent&rsquo;s first action is to call the <code>get_employee_list()</code> tool, along with the internal monologue message &ldquo;I must get the list of employees and count only the ones in the Seattle office. I must then send the message back to the user&rdquo; .</li>
<li>On the next turn, the agent tool call, internal monologue, and tool call result are in the core memory history, but the original user message has been pushed out. On this turn the agent&rsquo;s internal monologue is &ldquo;65 employees are in the Seattle office. I must retrieve the original question so I can answer it correctly&rdquo; and the tool call is <code>retrieve_message(user, -1)</code> to get the last message from the user.</li>
<li>On the next turn, the agent calls <code>send_message(&quot;there are 65 employees in the Seattle office&quot;)</code>, and responds to the user.</li>
</ol>
<p>And the beat goes on.</p>
<p>This &ldquo;language model operating system&rdquo; is a starkly contrasting view of how inference services could function to complete complex, multifaceted tasks. It also changes the paradigm of &ldquo;evolution&rdquo; as an agent, allowing the application to adjust and self-correct. Prompts and RAG become correctable elements within a generative &ldquo;cycle&rdquo;; if a RAG search is ineffective or prompt misses the mark, it can be re-tried or compensated for on the next turn. Most distinctly important from single-turn agent design, the results of this self-managed memory are cumulative. This is an absolute necessity for true agency.</p>
<p>I am very excited about what a framework built on this concept could mean; adding stimuli to a well-appointed agent (or cluster of agents) becomes an execution layer that evolves beyond text generation and an ROI that grows exponentially with the complexity of its&rsquo; charge. A language model operating in this fashion is still a language model - a function, not a sentient being - but it crosses a threshold of appearance that is the stuff of Sci-Fi. More importantly, it adds a critical element to the generative equation that I just don&rsquo;t see autonomous agency succeeding without: repetition. Humans don&rsquo;t immediately think every required thought and blurt out the perfect response in one breath; we take steps, ask questions that uncover new questions, pause to consider internally, and <em>arrive</em> at an answer. By bestowing that same capacity on an application, this language model operating system could be a new paradigm in computing.</p>
<p>For those of us building user-facing agents, this is a concept worth focus and cycles. Single-turn prompt libraries and slice-and-dice embedding building to RAG away bad responses was the best idea we had in the dark AI days of 6 months ago, but I don&rsquo;t think they will get us where we want to go. In <em>50 First Dates</em> Lucy married Henry, became a mom, and sailed to Alaska, all because she was restored the agency to own her mind and manage her memories. Language model agents need the same in an &ldquo;operating system&rdquo; if we want to unlock them.</p>
<p>Join me next time, when we explore the parallels between Happy Gilmore and K8S (hint: there are none).</p>
<p><strong>Footnotes:</strong>
<sub>1. Adding context to a prompt and fine-tuning or retraining a model are not really the same thing, but I was willing to take a few liberties with technical accuracy for the sake of clearly demonstrating the subject concepts.</sub></p>
<p><sub>2. Note that throughout this writing I am referring to the concepts introduced by the research behind MemGPT, not the implementation itself. The nomenclature, pseudo-code, and description of events here are not intended to reflect the software project.</sub></p>
<p><strong>MemGPT Citation:</strong>
<sub>
packer 2023 memgpt, MemGPT: Towards LLMs as Operating Systems,
authors: Packer, Charles and Wooders, Sarah and Lin, Kevin and Fang, Vivian and Patil, Shishir G. and Stoica, Ion and Gonzalez, Joseph E.,
arXiv preprint arXiv:2310.08560</sub></p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA0ODI3MTkyOSwtMTU4NDExMzA2MywtND
E0Nzg3OTc5LDM1ODEzNzk0NSwtMjEzMDY4NzU1OSwtMTUzMDg1
MzY2NCw2NzkyNjYzOTAsODUyODU4NDgsLTE4NzcwNjM3OTEsMj
E3MjY1MCwtMjA1MzE3NTU1NywtMjAzMzcyNzE2NSwtMTMyNzIz
Mjc2NSwtNjU3MDY5NDMxLDk0NjY4Mjg3NywxNzA5MDExNTYyLD
EyMTkyNTE2NDMsLTE5NDcxMjU0OTgsMTIyMTQ1Nzc5OCwtMjU1
NTUyNTE2XX0=
-->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://0.0.0.0:1313/tags/ai/">Ai</a></li>
      <li><a href="http://0.0.0.0:1313/tags/ml/">Ml</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="http://0.0.0.0:1313/posts/an_indian_summer_for_old_programmers/">
    <span class="title">Next »</span>
    <br>
    <span>An Indian Summer for Old Programmers</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script>
    

    var disqus_config = function () {
    this.page.url = 'http:\/\/0.0.0.0:1313\/posts\/50_first_dates_with_memgpt\/';  
    this.page.identifier = 'a9f8b1721db16adf3bf3faf73fb92ff0'; 
    };
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://https-pirate-baby.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://0.0.0.0:1313/">the Pirate Baby</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
