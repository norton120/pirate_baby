<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Langchain is a Ticking Timebomb | the Pirate Baby</title>
<meta name="keywords" content="AI">
<meta name="description" content="Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be the framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS &#x1f918;. So try not to disregard these observations as contrarian or success-hating; I really want to love LangChain.">
<meta name="author" content="">
<link rel="canonical" href="http://0.0.0.0:1313/posts/langchain_is_ticking_timebomb/">

  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QYLKP2XXPB"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-QYLKP2XXPB');
        }
      </script>
    
  


<link crossorigin="anonymous" href="/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css" integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://0.0.0.0:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://0.0.0.0:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://0.0.0.0:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://0.0.0.0:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://0.0.0.0:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://0.0.0.0:1313/posts/langchain_is_ticking_timebomb/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-QYLKP2XXPB"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-QYLKP2XXPB');
        }
      </script>
    
  

<meta property="og:title" content="Langchain is a Ticking Timebomb" />
<meta property="og:description" content="Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be the framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS &#x1f918;. So try not to disregard these observations as contrarian or success-hating; I really want to love LangChain." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://0.0.0.0:1313/posts/langchain_is_ticking_timebomb/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Langchain is a Ticking Timebomb"/>
<meta name="twitter:description" content="Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be the framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS &#x1f918;. So try not to disregard these observations as contrarian or success-hating; I really want to love LangChain."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://0.0.0.0:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Langchain is a Ticking Timebomb",
      "item": "http://0.0.0.0:1313/posts/langchain_is_ticking_timebomb/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Langchain is a Ticking Timebomb",
  "name": "Langchain is a Ticking Timebomb",
  "description": "Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be the framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS \u0026#x1f918;. So try not to disregard these observations as contrarian or success-hating; I really want to love LangChain.",
  "keywords": [
    "AI"
  ],
  "articleBody": "Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be the framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS ü§ò. So try not to disregard these observations as contrarian or success-hating; I really want to love LangChain.\nWhen we began work on our inference engine back in October 2023 (so a millennia ago in LLM time) LangChain was the obvious choice. By the first week of December we had abandoned the framework, and by Christmas we had written our own internal prompt templating module to support a Q1 product launch. Such a drastic architectural change at an equally critical time in the product life cycle is not a thing to take lightly. But the growing collection of red flags became something we could not ignore, and I believe we made the best decision.\nWhat red flags?\nDependency Management If you‚Äôve been around the Python ecosystem for more than a minute, you know that dependencies are the Achilles‚Äô heel of the language. This is true for Python as a whole, but I have found this to be exponentially worse in the data sphere. When Software Engineering, Data Engineering and Data Science coalesce, you find deeply abstracted package dependencies with pins like Cython=\u003e0.1 that ‚Äúworked before,‚Äù and lurk in the darkness of deployed code waiting to ruin your weekend. A few years ago the snowflake-sqlalchemy adapter was so often the source of surprise dependency failures that my team would comment we're not snowflake whenever a bad pin made it to a PR review. The general wisdom is to minimize the surface area of dependencies by importing only what your code needs to survive. LangChain does the opposite of this. The framework currently boasts over 200 supported integrations, every one of them a dependency. If something breaks in the requirements management of the Discord integration, it breaks your project, regardless of if you use Discord or not. In November of 2023 this resulted in what is essentially a text compiling framework that takes 18 minutes to build in a container. It was a hopeful sign when LangChain announced that the framework would be split into langchain-core and langchain-community packages - great! dependency isolation! But as of now that split is still largely academic. Yes there is a langchain-core package, which in itself provides little functionality and still feels extremely coupled to the community ecosystem (more on that in a moment). But if you want any of the integration support you are forced to once again adopt the whole wad of integration spaghetti - back to square one. Before LangChain announced a December 7th date to release langchain-core, I had taken two days in November to fork the library and try to carve a core implementation out myself. That‚Äôs when I discovered the next of our red flags.\nOnion Wrapper Architecture There are dozens of ‚ÄúI re-implemented LangChain in 40 lines of code‚Äù posts on Reddit and Medium; I would love to dismiss them all as clickbait, but in truth our prompt templating engine is a couple hundred lines of readable code, and most of our composable ‚Äúlinks‚Äù that make up our chains are less than 30 lines. The LangChain codebase is understandably rushed (2023 was the AI land grab, and a lot of hard choices are made when speed is so critical). But there is a specific pattern, one quite common with inexperienced Software Engineers under pressure, that doesn‚Äôt just pepper the code base - it is the primary flavor. That flavor is onion wrapper architecture. It goes something like this:\nI get a thing working for an extremely specific use case I need some of the functionality from that thing, or all of it in a different context, but it has been a minute and I don‚Äôt really understand how the first thing works. So I import the first thing, wrap it in another thing in my new module, then expose that thing I need parts from the second thing, but don‚Äôt really understand how that thing works because it‚Äôs a sort of mangled version of the first thing, so I import that second thing into a third module and wrap that with more code that works, at the moment. Rinse and repeat, until changing a single quote in a prompt requires you to have 35 files with 1100 lines each open in your text editor. There are a ton of reasons this kind of design happens - unreasonable delivery demands being one of them, a wide-open-door contribution policy being another. We have all worked on application codebases that look like this - they are the ones that crash all the time with no warning, take forever to get back up by piling more spaghetti on the mound, and are nearly impossible to add new features or fixes to. Behaviors are hidden deep in the stack (‚Äúwhere did this random timeout setting come from?!?‚Äù), and side-effects take on a black magic all their own. The idea of building on a framework that looks like this‚Ä¶ that is frightening. Frameworks are your bedrock, they are the solid base on which applications are erected. Framework code is arguably the highest form of software development, meta-programming at its most impactful. Frameworks are not a place to ship-now-at-all-costs, they are the code that must be reliable for the applications that depend on them to flourish.\nNot an Application Framework LangChain describes itself as a ‚Äúframework for developing applications powered by language models.‚Äù I disagree. LangChain is a software package, a collection of modules, but it lacks the core elements of what can be reasonably called a framework. It is one thing to develop reusable code elements (these are modules), another thing to make that code portable (these are packages). A framework goes beyond ‚Äúhere‚Äôs a way to access some functions you can use.‚Äù It is an inherent architecture, a structure that manages how parts of your code interact with each other. Airflow is a framework - it uses file system organization to create a familiar pattern across airflow instances, makes opinionated design decisions that ensure the application will function as a whole if adhered to. FastAPI is a framework that does not leverage the filesystem - it has a clear pattern using routers, routes, lifecycle events and dependencies. Even with a non-standard implementation of FastAPI, most developers can grok what is happening and where with few ctrl+f searches for baseline elements. Frameworks answer the very difficult question of ‚Äúhow should the parts of my code work together?‚Äù. LangChain does none of this, and is functionally closer to a library like requests than it is to an application framework like Next.js or Rails. The most glaring example of the is the LangChain documentation, where every example exists as a notebook cell. This reflects how LangChain is designed - specifically for isolated scripting, and not as a component in a multifaceted application. Pick any framework - Django, Phoenix, Electron - and note how many points in the documentation refer to multiple files:\n# my_route.py from my_model import Bla ... all_the_foos = await Bla.awaitable_attrs.foos # my_model.py class Bla(Base): foos:list[Foo] = relationship(...) When your framework is designed as a pile of scripts, your application becomes a huge pile of scripts.\nHuh? Moments This was the last red flag, the proverbial nail in our LangChain-shaped coffin. About the time we were realizing that the larger langchain package was not what we wanted and began attempting to extract langchain-core on our own, a similar discussion thread appeared within the LangChain repo. We were excited to see the parity of thought! But a comment regarding version strategy stood out to all of the team: I read this as ‚Äú_we are going to break things all the time and we‚Äôd rather just ship whatever whenever and not worry about the impact of regressions on your code.‚Äù The space is changing fast, and because of that fact correct versioning is critical. Many of the language-model-related packages we use are already several majors behind from only a few weeks ago - and that is our problem, because the space is moving fast and we need to decide when we will do the painful upgrades. But deciding, as a library, not to correctly version because braking changes are expected often‚Ä¶ that‚Äôs like saying ‚Äúwe know the probability of a heart attack is really high, so we‚Äôre going to get rid of your fitbits so we don‚Äôt need to deal with warning signs.‚Äù\nI have hope A month after we made the decision to abandon LangChain, much has changed. V.0.1.0 was released, promising a stable entrypoint and, eh, interesting (non-semantic) versioning (but hey at least they set rules?). LangChain is moving to a sensible stand-alone packages model for integrations. It would be amazing if we see the project mature into either a stable, reliable library, or evolve into a true llm-application framework. And I‚Äôll be the first person to condemn our bespoke code to reside in git history and wire up a Lang*-based chain, when (and if) that day comes. But I am confident that the LangChain of right-at-this-moment will be the very center of unreliable, painfully brittle code bases that organizations are desperate to get away from this time next year.\n",
  "wordCount" : "1583",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://0.0.0.0:1313/posts/langchain_is_ticking_timebomb/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "the Pirate Baby",
    "logo": {
      "@type": "ImageObject",
      "url": "http://0.0.0.0:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://0.0.0.0:1313/" accesskey="h" title="the Pirate Baby (Alt + H)">
                        
                    <img src="http://0.0.0.0:1313/piratebaby_huaab79433917d743d4e178df45e5313e8_505492_0x40_resize_box_3.png" alt="" aria-label="logo"
                        height="40">the Pirate Baby</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://0.0.0.0:1313/work-with-pirate-baby/" title="C&amp;C">
                    <span>C&amp;C</span>
                </a>
            </li>
            <li>
                <a href="http://0.0.0.0:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://0.0.0.0:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://0.0.0.0:1313/">Home</a>&nbsp;¬ª&nbsp;<a href="http://0.0.0.0:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Langchain is a Ticking Timebomb
    </h1>
    <div class="post-meta">8 min

</div>
  </header> 
  <div class="post-content"><p>Let me preface this by saying that I very much appreciate the entire Lang* ecosystem. At my shop we rely heavily on Langfuse for development as well as the tagging interface for our training strategy. More than a few platforms have tried to be <em>the</em> framework for language model applications (think Guidance, Haystack etc), and the Lang* team has arguably made the most headway, and done it OSS &#x1f918;. So try not to disregard these observations as contrarian or success-hating; I really <em>want</em> to love LangChain.</p>
<p>When we began work on our inference engine back in October 2023 (so a millennia ago in LLM time) LangChain was the obvious choice. By the first week of December we had abandoned the framework, and by Christmas we had written our own internal prompt templating module to support a Q1 product launch. Such a drastic architectural change at an equally critical time in the product life cycle is not a thing to take lightly. But the growing collection of red flags became something we could not ignore, and I believe we made the best decision.</p>
<p>What red flags?</p>
<h3 id="dependency-management">Dependency Management<a hidden class="anchor" aria-hidden="true" href="#dependency-management">#</a></h3>
<p>If you&rsquo;ve been around the Python ecosystem for more than a minute, you know that dependencies are the Achilles&rsquo; heel of the language. This is true for Python as a whole, but I have found this to be exponentially worse in the data sphere. When Software Engineering, Data Engineering and Data Science coalesce, you find deeply abstracted package dependencies with pins like <code>Cython=&gt;0.1</code> that &ldquo;worked before,&rdquo; and lurk in the darkness of deployed code waiting to ruin your weekend. A few years ago the <code>snowflake-sqlalchemy</code> adapter was so often the source of surprise dependency failures that my team would comment <code>we're not snowflake</code> whenever a bad pin made it to a PR review.
The general wisdom is to minimize the surface area of dependencies by importing only what your code needs to survive.
<img loading="lazy" src="https://y.yarn.co/84492e53-9f7f-42c3-a8c3-bd088fe3d7fe_text.gif" alt="take only what you need to survive"  />
</p>
<p>LangChain does the opposite of this. The framework currently boasts over 200 supported integrations, every one of them a dependency. If something breaks in the requirements management of the Discord integration, it breaks your project, regardless of if you use Discord or not.
In November of 2023 this resulted in what is essentially a text compiling framework that takes 18 minutes to build in a container. It was a hopeful sign when LangChain announced that the framework would be split into <code>langchain-core</code> and <code>langchain-community</code> packages - great! dependency isolation! But as of now that split is still largely academic. Yes there is a <code>langchain-core</code> package, which in itself provides little functionality and still feels extremely coupled to the community ecosystem (more on that in a moment). But if you want any of the integration support you are forced to once again adopt the whole wad of integration spaghetti - back to square one. Before LangChain announced a December 7th date to release <code>langchain-core</code>, I had taken two days in November to fork the library and try to carve a <code>core</code> implementation out myself. That&rsquo;s when I discovered the next of our red flags.</p>
<h3 id="onion-wrapper-architecture">Onion Wrapper Architecture<a hidden class="anchor" aria-hidden="true" href="#onion-wrapper-architecture">#</a></h3>
<p>There are dozens of &ldquo;I re-implemented LangChain in 40 lines of code&rdquo; posts on Reddit and Medium; I would love to dismiss them all as clickbait, but in truth our prompt templating engine is a couple hundred lines of readable code, and most of our composable &ldquo;links&rdquo; that make up our chains are less than 30 lines.
The LangChain codebase is understandably rushed (2023 was the AI land grab, and a lot of hard choices are made when speed is so critical). But there is a specific pattern, one quite common with inexperienced Software Engineers under pressure, that doesn&rsquo;t just pepper the code base - it is the primary flavor. That flavor is <em>onion wrapper</em> architecture. It goes something like this:</p>
<ol>
<li>I get a thing working for an extremely specific use case</li>
<li>I need some of the functionality from that thing, or all of it in a different context, but it has been a minute and I don&rsquo;t really understand how the first thing works. So I import the first thing, wrap it in another thing in my new module, then expose that thing</li>
<li>I need parts from the second thing, but don&rsquo;t really understand how that thing works because it&rsquo;s a sort of mangled version of the first thing, so I import that second thing into a third module and wrap <em>that</em> with more code that works, at the moment.</li>
<li>Rinse and repeat, until changing a single quote in a prompt requires you to have 35 files with 1100 lines each open in your text editor.
There are a ton of reasons this kind of design happens - unreasonable delivery demands being one of them, a wide-open-door contribution policy being another. We have all worked on <em>application</em> codebases that look like this - they are the ones that crash all the time with no warning, take forever to get back up by piling more spaghetti on the mound, and are nearly impossible to add new features or fixes to. Behaviors are hidden deep in the stack (&ldquo;where did this random timeout setting come from?!?&rdquo;), and side-effects take on a black magic all their own. The idea of building on a <em>framework</em> that looks like this&hellip; that is frightening.</li>
</ol>
<p>Frameworks are your bedrock, they are the solid base on which applications are erected. Framework code is arguably the highest form of software development, meta-programming at its most impactful. Frameworks are not a place to ship-now-at-all-costs, they are the code that must be reliable for the applications that depend on them to flourish.</p>
<h3 id="not-an-application-framework">Not an Application Framework<a hidden class="anchor" aria-hidden="true" href="#not-an-application-framework">#</a></h3>
<p>LangChain describes itself as a &ldquo;framework for developing applications powered by language models.&rdquo; I disagree. LangChain is a software package, a collection of modules, but it lacks the core elements of what can be reasonably called a framework. It is one thing to develop reusable code elements (these are modules), another thing to make that code portable (these are packages). A <em>framework</em> goes beyond &ldquo;here&rsquo;s a way to access some functions you can use.&rdquo; It is an inherent architecture, a structure that manages how parts of your code interact with each other. Airflow is a framework - it uses file system organization to create a familiar pattern across airflow instances, makes opinionated design decisions that ensure the <em>application</em> will function as a whole if adhered to. FastAPI is a framework that does not leverage the filesystem - it has a clear pattern using routers, routes, lifecycle events and dependencies. Even with a non-standard implementation of FastAPI, most developers can grok what is happening and where with few <code>ctrl+f</code> searches for baseline elements.
Frameworks answer the very difficult question of &ldquo;how should the parts of my code work together?&rdquo;. LangChain does none of this, and is functionally closer to a library like <code>requests</code> than it is to an application framework like <em>Next.js</em> or <em>Rails</em>.
The most glaring example of the is the LangChain documentation, where every example exists as a notebook cell. This reflects how LangChain is designed - specifically for isolated scripting, and not as a component in a multifaceted application. Pick any framework - <em>Django, Phoenix, Electron</em> - and note how many points in the documentation refer to multiple files:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># my_route.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">my_model</span> <span class="kn">import</span> <span class="n">Bla</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">all_the_foos</span> <span class="o">=</span> <span class="k">await</span> <span class="n">Bla</span><span class="o">.</span><span class="n">awaitable_attrs</span><span class="o">.</span><span class="n">foos</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># my_model.py</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bla</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">foos</span><span class="p">:</span><span class="nb">list</span><span class="p">[</span><span class="n">Foo</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</span></span></code></pre></div><p>When your framework is designed as a pile of scripts, your application becomes a huge pile of scripts.</p>
<h3 id="huh-moments">Huh? Moments<a hidden class="anchor" aria-hidden="true" href="#huh-moments">#</a></h3>
<p>This was the last red flag, the proverbial nail in our LangChain-shaped coffin. About the time we were realizing that the larger <code>langchain</code> package was not what we wanted and began attempting to extract <code>langchain-core</code> on our own, a similar discussion thread appeared within the LangChain repo. We were excited to see the parity of thought! But <a href="https://github.com/langchain-ai/langchain/discussions/13823#discussioncomment-7682401">a comment</a> regarding version strategy stood out to all of the team:
<img loading="lazy" src="/images/versioning.png" alt="versioning"  />
</p>
<p>I read this as &ldquo;_we are going to break things all the time and we&rsquo;d rather just ship whatever whenever and not worry about the impact of regressions on your code.&rdquo; The space <em>is</em> changing fast, and because of that fact correct versioning is critical. Many of the language-model-related packages we use are already several <em>majors</em> behind from only a few weeks ago - and that is <strong>our</strong> problem, because the space is moving fast and we need to decide when we will do the painful upgrades. But deciding, as a library, not to correctly version because braking changes are expected often&hellip; that&rsquo;s like saying &ldquo;we know the probability of a heart attack is really high, so we&rsquo;re going to get rid of your fitbits so we don&rsquo;t need to deal with warning signs.&rdquo;</p>
<h3 id="i-have-hope">I have hope<a hidden class="anchor" aria-hidden="true" href="#i-have-hope">#</a></h3>
<p>A month after we made the decision to abandon LangChain, much has changed. <code>V.0.1.0</code> was released, promising a stable entrypoint and, eh, interesting (<a href="https://blog.langchain.dev/langchain-v0-1-0/#:~:text=Any%20breaking%20changes%20to%20the%20public%20API%20will%20result%20in%20a%20minor%20version%20bump%20%28the%20second%20digit%29">non-semantic</a>) versioning (but hey at least they set rules?). LangChain is moving to a sensible <a href="https://github.com/langchain-ai/langchain/tree/master/libs/partners?ref=blog.langchain.dev">stand-alone packages</a> model for integrations. It would be amazing if we see the project mature into either a stable, reliable library, or evolve into a true llm-application framework. And I&rsquo;ll be the first person to condemn our bespoke code to reside in git history and wire up a Lang*-based chain, when (and if) that day comes. But I am confident that the LangChain of right-at-this-moment will be the very center of unreliable, painfully  brittle code bases that organizations are desperate to get away from this time next year.</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzMjM5MzYwMDMsLTE5NjQwMjE2MDYsLT
k4MzY2MjIxMiwtOTM4NDgwMjg3LC0xNTU3NTgyMjcsMTIxMzQz
NjYzOCwxMzgyMzYzMzRdfQ==
-->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://0.0.0.0:1313/tags/ai/">Ai</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://0.0.0.0:1313/posts/caffeine/">
    <span class="title">¬´ Prev</span>
    <br>
    <span>Caffeine</span>
  </a>
  <a class="next" href="http://0.0.0.0:1313/posts/prompt_engineering/">
    <span class="title">Next ¬ª</span>
    <br>
    <span>Prompt Engineering</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script>
    

    var disqus_config = function () {
    this.page.url = 'http:\/\/0.0.0.0:1313\/posts\/langchain_is_ticking_timebomb\/';  
    this.page.identifier = 'e77878bf7c5e07b04f17d82e56c2fb52'; 
    };
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://https-pirate-baby.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://0.0.0.0:1313/">the Pirate Baby</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
